package com.composum.ai.backend.base.service.chat.impl;

import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentSkipListSet;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A quick HTML markdown converter that handles the tags [a, strong, code, em, p, br, u, ul, li, ol] used in rich text editor.
 * Not threadsafe, use only once.
 * <p>
 * We do not want to use a library since the libraries doing this have many parts and are quite some work to deploy, and
 * we only need to convert a few tags from richtext editors.
 * Original generated by ChatGPT with "Please make an HTML to Markdown converter that handles the tags [a, strong, code, em, p, br, u, ul, li, ol] . Use the jsoup library for that."
 * but some heavy rewrite.
 */
public class HtmlToMarkdownConverter {

    private static final Logger LOG = LoggerFactory.getLogger(HtmlToMarkdownConverter.class);

    private static Set<String> missingTags = new ConcurrentSkipListSet<>();

    private static final Map<String, String> HEADER_TAGS = Map.of("h1", "# ", "h2", "## ", "h3",
            "### ", "h4", "#### ", "h5", "##### ", "h6", "###### ");

    private final String indentStep = "    ";

    private String indentation = "";

    private StringBuilder sb = new StringBuilder();

    public String convert(String html) {
        if (html != null) {
            Document doc = Jsoup.parseBodyFragment(html);
            convertElement(doc.body());
        }
        return sb.toString();
    }

    private void convertNode(Node node) {
        if (node instanceof TextNode) {
            TextNode textNode = (TextNode) node;
            sb.append(textNode.text());
        } else if (node instanceof Element) {
            Element element = (Element) node;
            convertElement(element);
        } else {
            throw new UnsupportedOperationException("Unknown node type " + node.getClass());
        }
    }

    private void convertChildren(Node node) {
        for (Node child : node.childNodes()) {
            convertNode(child);
        }
    }

    private void convertElement(Element element) {
        String tagName = element.tagName().toLowerCase();
        switch (tagName) {
            case "a":
                sb.append("[");
                convertChildren(element);
                sb.append("](");
                sb.append(element.attr("href"));
                sb.append(")");
                break;

            case "em":
                sb.append("_");
                convertChildren(element);
                sb.append("_");
                break;

            case "b":
            case "strong":
                sb.append("**");
                convertChildren(element);
                sb.append("**");
                break;

            case "i":
                sb.append("*");
                convertChildren(element);
                sb.append("*");
                break;

            case "u":
                sb.append("_");
                sb.append(element.html().replaceAll("\\s+", "_"));
                sb.append("_");
                break;

            case "del":
            case "s":
                sb.append("~~");
                convertChildren(element);
                sb.append("~~");
                break;

            case "code":
                sb.append("`");
                convertChildren(element);
                sb.append("`");
                break;

            case "pre": // TODO: a pre code nesting would be wrong.
                sb.append("```\n");
                sb.append(element.html());
                sb.append("\n```\n");
                break;

            case "p":
                convertChildren(element);
                sb.append("\n\n");
                break;

            case "br":
                sb.append("\n");
                break;

            case "ul": // TODO: list nesting isn't handled properly here.
                for (Element li : element.children()) {
                    sb.append("- ");
                    convertChildren(li);
                    sb.append("\n");
                }
                sb.append("\n");
                break;

            case "ol": // TODO: list nesting isn't handled properly here.
                int i = 1;
                for (Element li : element.children()) {
                    sb.append(i++);
                    sb.append(". ");
                    convertChildren(li);
                    sb.append("\n");
                }
                sb.append("\n");
                break;

            case "li":
                throw new UnsupportedOperationException("Bug: li should be handled by ul or ol");

            case "img":
                sb.append("![");
                sb.append(element.attr("alt"));
                sb.append("](");
                sb.append(element.attr("src"));
                sb.append(")");
                break;

            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
                String prefix = HEADER_TAGS.get(tagName);
                sb.append(prefix);
                convertChildren(element);
                sb.append("\n");
                break;

            case "hr":
                sb.append("---\n");
                break;

            case "input":
                String type = element.attr("type");
                String placeholder = element.attr("placeholder");
                sb.append("[Input: Type=");
                sb.append(type.isEmpty() ? "text" : type);
                if (!placeholder.isEmpty()) {
                    sb.append(", Placeholder=");
                    sb.append(placeholder);
                }
                sb.append("]");
                break;

            case "dl": // there is no markdown for dl, so we just use embedded HTML. Possibly it could also be
                // **term**
                // definition
                //
                sb.append("<dl>\n");
                convertChildren(element);
                sb.append("</dl>\n");
                break;

            case "dt":
                sb.append("  <dt>");
                convertChildren(element);
                sb.append("</dt>\n");
                break;

            case "dd":
                sb.append("  <dd>");
                convertChildren(element);
                sb.append("</dd>\n");
                break;

            case "blockquote":
                sb.append("> ");
                String[] lines = element.html().split("\n");
                for (String line : lines) {
                    sb.append(line);
                    sb.append("\n> ");
                }
                sb.append("\n");
                break;

            case "#root":
            case "html":
            case "body":
            case "span":
            case "div":
                convertChildren(element);
                break;

            case "noscript":
            case "meta":
            case "nav":
                break;

            default:
                // ignore tags we do not know
                LOG.warn("Unknown tag {}", tagName);
                missingTags.add(tagName);
                LOG.warn("Currently unsupported tags: {}", missingTags);
                // blockquote, dd, dl, dt, input
                convertChildren(element);
                break;
        }
    }
}
